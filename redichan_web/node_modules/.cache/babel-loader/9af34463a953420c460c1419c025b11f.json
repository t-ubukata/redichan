{"ast":null,"code":"'use strict';\n\nconst path = require('path');\nconst is = require('./is');\nconst sharp = require('./sharp');\nconst formats = new Map([['heic', 'heif'], ['heif', 'heif'], ['avif', 'avif'], ['jpeg', 'jpeg'], ['jpg', 'jpeg'], ['png', 'png'], ['raw', 'raw'], ['tiff', 'tiff'], ['tif', 'tiff'], ['webp', 'webp'], ['gif', 'gif'], ['jp2', 'jp2'], ['jpx', 'jp2'], ['j2k', 'jp2'], ['j2c', 'jp2']]);\nconst errJp2Save = new Error('JP2 output requires libvips with support for OpenJPEG');\nconst bitdepthFromColourCount = colours => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile(fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    return this._pipeline(callback);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer(options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * This will also convert to and add a web-friendly sRGB ICC profile unless a custom\n * output profile is provided.\n *\n * The default behaviour, when `withMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @example\n * // Set \"IFD0-Copyright\" in output EXIF metadata\n * const data = await sharp(input)\n *   .withMetadata({\n *     exif: {\n *       IFD0: {\n *         Copyright: 'Wernham Hogg'\n *       }\n *     }\n *   })\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @param {string} [options.icc] filesystem path to output ICC profile, defaults to sRGB.\n * @param {Object<Object>} [options.exif={}] Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata(options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      if (is.string(options.icc)) {\n        this.options.withMetadataIcc = options.icc;\n      } else {\n        throw is.invalidParameterError('icc', 'string filesystem path to ICC profile', options.icc);\n      }\n    }\n    if (is.defined(options.exif)) {\n      if (is.object(options.exif)) {\n        for (const [ifd, entries] of Object.entries(options.exif)) {\n          if (is.object(entries)) {\n            for (const [k, v] of Object.entries(entries)) {\n              if (is.string(v)) {\n                this.options.withMetadataStrs[`exif-${ifd.toLowerCase()}-${k}`] = v;\n              } else {\n                throw is.invalidParameterError(`exif.${ifd}.${k}`, 'string', v);\n              }\n            }\n          } else {\n            throw is.invalidParameterError(`exif.${ifd}`, 'object', entries);\n          }\n        }\n      } else {\n        throw is.invalidParameterError('exif', 'object', options.exif);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat(format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png(options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      const colours = options.colours || options.colors;\n      if (is.defined(colours)) {\n        if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n          this.options.pngBitdepth = bitdepthFromColourCount(colours);\n        } else {\n          throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    const effort = is.defined(options.effort) ? options.effort : options.reductionEffort;\n    if (is.defined(effort)) {\n      if (is.integer(effort) && is.inRange(effort, 0, 6)) {\n        this.options.webpEffort = effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', effort);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif(options) {\n  if (is.object(options)) {\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n/* istanbul ignore next */\nfunction jp2(options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save;\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions(source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link withMetadata} instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: lzw, deflate, jpeg, ccittfax4\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['lzw', 'deflate', 'jpeg', 'ccittfax4', 'none'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: lzw, deflate, jpeg, ccittfax4, none', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * Whilst it is possible to create AVIF images smaller than 16x16 pixels,\n * most web browsers do not display these properly.\n *\n * AVIF image sequences are not supported.\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif(options) {\n  return this.heif({\n    ...options,\n    compression: 'av1'\n  });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {string} [options.compression='av1'] - compression format: av1, hevc\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    } else if (is.defined(options.speed)) {\n      if (is.integer(options.speed) && is.inRange(options.speed, 0, 9)) {\n        this.options.heifEffort = 9 - options.speed;\n      } else {\n        throw is.invalidParameterError('speed', 'integer between 0 and 9', options.speed);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @throws {Error} Invalid options\n */\nfunction raw(options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex'])) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile(options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout(options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut(formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption(key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read() {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    this._pipeline();\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline(callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.emit('close');\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.emit('close');\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({\n                  data,\n                  info\n                });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({\n                data: data,\n                info: info\n              });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};","map":{"version":3,"names":["path","require","is","sharp","formats","Map","errJp2Save","Error","bitdepthFromColourCount","colours","Math","clz32","ceil","log2","toFile","fileOut","callback","err","string","options","input","file","resolve","fn","Promise","reject","_pipeline","toBuffer","object","_setBooleanOption","resolveWithObject","withMetadata","bool","defined","orientation","integer","inRange","withMetadataOrientation","invalidParameterError","density","number","withMetadataDensity","icc","withMetadataIcc","exif","ifd","entries","Object","k","v","withMetadataStrs","toLowerCase","toFormat","format","actualFormat","get","id","keys","join","jpeg","quality","jpegQuality","progressive","chromaSubsampling","inArray","jpegChromaSubsampling","optimiseCoding","optimizeCoding","mozjpeg","jpegTrellisQuantisation","jpegOvershootDeringing","jpegOptimiseScans","jpegProgressive","jpegQuantisationTable","trellisQuantisation","trellisQuantization","overshootDeringing","optimiseScans","optimizeScans","quantisationTable","quantizationTable","_updateFormatOut","png","compressionLevel","pngCompressionLevel","adaptiveFiltering","palette","effort","colors","dither","some","pngPalette","pngQuality","pngEffort","pngBitdepth","pngDither","webp","webpQuality","alphaQuality","webpAlphaQuality","lossless","nearLossless","smartSubsample","reductionEffort","webpEffort","trySetAnimationOptions","gif","gifBitdepth","gifEffort","gifDither","jp2","constructor","jp2k","output","buffer","jp2Quality","jp2Lossless","tileWidth","jp2TileWidth","tileHeight","jp2TileHeight","heifChromaSubsampling","source","target","loop","delay","Array","isArray","every","tiff","tiffQuality","bitdepth","tiffBitdepth","tile","tiffTileWidth","tiffTileHeight","pyramid","xres","tiffXres","yres","tiffYres","compression","tiffCompression","predictor","tiffPredictor","resolutionUnit","tiffResolutionUnit","avif","heif","heifQuality","heifLossless","heifCompression","heifEffort","speed","raw","depth","rawDepth","size","tileSize","overlap","tileOverlap","container","tileContainer","layout","tileLayout","angle","tileAngle","_setBackgroundColourOption","background","tileDepth","skipBlanks","tileSkipBlanks","centre","center","tileId","formatOut","tileFormat","timeout","plainObject","seconds","timeoutSeconds","force","key","val","_read","streamOut","_isStreamInput","on","_flattenBufferIn","pipeline","once","data","info","emit","push","streamInFinished","module","exports","Sharp","assign","prototype"],"sources":["/Users/admin/project/redichan_frontend/node_modules/sharp/lib/output.js"],"sourcesContent":["'use strict';\n\nconst path = require('path');\nconst is = require('./is');\nconst sharp = require('./sharp');\n\nconst formats = new Map([\n  ['heic', 'heif'],\n  ['heif', 'heif'],\n  ['avif', 'avif'],\n  ['jpeg', 'jpeg'],\n  ['jpg', 'jpeg'],\n  ['png', 'png'],\n  ['raw', 'raw'],\n  ['tiff', 'tiff'],\n  ['tif', 'tiff'],\n  ['webp', 'webp'],\n  ['gif', 'gif'],\n  ['jp2', 'jp2'],\n  ['jpx', 'jp2'],\n  ['j2k', 'jp2'],\n  ['j2c', 'jp2']\n]);\n\nconst errJp2Save = new Error('JP2 output requires libvips with support for OpenJPEG');\n\nconst bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile (fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    return this._pipeline(callback);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer (options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * This will also convert to and add a web-friendly sRGB ICC profile unless a custom\n * output profile is provided.\n *\n * The default behaviour, when `withMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @example\n * // Set \"IFD0-Copyright\" in output EXIF metadata\n * const data = await sharp(input)\n *   .withMetadata({\n *     exif: {\n *       IFD0: {\n *         Copyright: 'Wernham Hogg'\n *       }\n *     }\n *   })\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @param {string} [options.icc] filesystem path to output ICC profile, defaults to sRGB.\n * @param {Object<Object>} [options.exif={}] Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata (options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      if (is.string(options.icc)) {\n        this.options.withMetadataIcc = options.icc;\n      } else {\n        throw is.invalidParameterError('icc', 'string filesystem path to ICC profile', options.icc);\n      }\n    }\n    if (is.defined(options.exif)) {\n      if (is.object(options.exif)) {\n        for (const [ifd, entries] of Object.entries(options.exif)) {\n          if (is.object(entries)) {\n            for (const [k, v] of Object.entries(entries)) {\n              if (is.string(v)) {\n                this.options.withMetadataStrs[`exif-${ifd.toLowerCase()}-${k}`] = v;\n              } else {\n                throw is.invalidParameterError(`exif.${ifd}.${k}`, 'string', v);\n              }\n            }\n          } else {\n            throw is.invalidParameterError(`exif.${ifd}`, 'object', entries);\n          }\n        }\n      } else {\n        throw is.invalidParameterError('exif', 'object', options.exif);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat (format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png (options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      const colours = options.colours || options.colors;\n      if (is.defined(colours)) {\n        if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n          this.options.pngBitdepth = bitdepthFromColourCount(colours);\n        } else {\n          throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    const effort = is.defined(options.effort) ? options.effort : options.reductionEffort;\n    if (is.defined(effort)) {\n      if (is.integer(effort) && is.inRange(effort, 0, 6)) {\n        this.options.webpEffort = effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', effort);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif (options) {\n  if (is.object(options)) {\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n/* istanbul ignore next */\nfunction jp2 (options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save;\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions (source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (\n      Array.isArray(source.delay) &&\n      source.delay.every(is.integer) &&\n      source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link withMetadata} instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: lzw, deflate, jpeg, ccittfax4\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['lzw', 'deflate', 'jpeg', 'ccittfax4', 'none'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: lzw, deflate, jpeg, ccittfax4, none', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * Whilst it is possible to create AVIF images smaller than 16x16 pixels,\n * most web browsers do not display these properly.\n *\n * AVIF image sequences are not supported.\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif (options) {\n  return this.heif({ ...options, compression: 'av1' });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {string} [options.compression='av1'] - compression format: av1, hevc\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    } else if (is.defined(options.speed)) {\n      if (is.integer(options.speed) && is.inRange(options.speed, 0, 9)) {\n        this.options.heifEffort = 9 - options.speed;\n      } else {\n        throw is.invalidParameterError('speed', 'integer between 0 and 9', options.speed);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @throws {Error} Invalid options\n */\nfunction raw (options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth,\n        ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex']\n      )) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile (options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut (formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption (key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read () {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    this._pipeline();\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline (callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.emit('close');\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.emit('close');\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({ data, info });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({ data: data, info: info });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}