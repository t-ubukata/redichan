{"ast":null,"code":"\"use strict\";\n\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JPG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n// Each entry is exactly 12 bytes\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(buffer) {\n  return buffer.toString('hex', 2, 6) === EXIF_MARKER;\n}\nfunction extractSize(buffer, index) {\n  return {\n    height: buffer.readUInt16BE(index),\n    width: buffer.readUInt16BE(index + 2)\n  };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n  // TODO: assert that this contains 0x002A\n  // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n  // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n  // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n  const idfOffset = 8;\n  // IDF osset works from right after the header bytes\n  // (so the offset includes the tiff byte align)\n  const offset = EXIF_HEADER_BYTES + idfOffset;\n  const idfDirectoryEntries = (0, readUInt_1.readUInt)(exifBlock, 16, offset, isBigEndian);\n  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;\n    const end = start + IDF_ENTRY_BYTES;\n    // Skip on corrupt EXIF blocks\n    if (start > exifBlock.length) {\n      return;\n    }\n    const block = exifBlock.slice(start, end);\n    const tagNumber = (0, readUInt_1.readUInt)(block, 16, 0, isBigEndian);\n    // 0x0112 (decimal: 274) is the `orientation` tag ID\n    if (tagNumber === 274) {\n      const dataFormat = (0, readUInt_1.readUInt)(block, 16, 2, isBigEndian);\n      if (dataFormat !== 3) {\n        return;\n      }\n      // unsinged int has 2 bytes per component\n      // if there would more than 4 bytes in total it's a pointer\n      const numberOfComponents = (0, readUInt_1.readUInt)(block, 32, 4, isBigEndian);\n      if (numberOfComponents !== 1) {\n        return;\n      }\n      return (0, readUInt_1.readUInt)(block, 16, 8, isBigEndian);\n    }\n  }\n}\nfunction validateExifBlock(buffer, index) {\n  // Skip APP1 Data Size\n  const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);\n  // Consider byte alignment\n  const byteAlign = exifBlock.toString('hex', EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n  // Ignore Empty EXIF. Validate byte alignment\n  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\nfunction validateBuffer(buffer, index) {\n  // index should be within buffer limits\n  if (index > buffer.length) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  }\n  // Every JPEG block must begin with a 0xFF\n  if (buffer[index] !== 0xFF) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n}\nexports.JPG = {\n  validate(buffer) {\n    const SOIMarker = buffer.toString('hex', 0, 2);\n    return 'ffd8' === SOIMarker;\n  },\n  calculate(buffer) {\n    // Skip 4 chars, they are for signature\n    buffer = buffer.slice(4);\n    let orientation;\n    let next;\n    while (buffer.length) {\n      // read length of the next block\n      const i = buffer.readUInt16BE(0);\n      if (isEXIF(buffer)) {\n        orientation = validateExifBlock(buffer, i);\n      }\n      // ensure correct format\n      validateBuffer(buffer, i);\n      // 0xFFC0 is baseline standard(SOF)\n      // 0xFFC1 is baseline optimized(SOF)\n      // 0xFFC2 is progressive(SOF2)\n      next = buffer[i + 1];\n      if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n        const size = extractSize(buffer, i + 5);\n        // TODO: is orientation=0 a valid answer here?\n        if (!orientation) {\n          return size;\n        }\n        return {\n          height: size.height,\n          orientation,\n          width: size.width\n        };\n      }\n      // move to the next block\n      buffer = buffer.slice(i + 2);\n    }\n    throw new TypeError('Invalid JPG, no size found');\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","JPG","readUInt_1","require","EXIF_MARKER","APP1_DATA_SIZE_BYTES","EXIF_HEADER_BYTES","TIFF_BYTE_ALIGN_BYTES","BIG_ENDIAN_BYTE_ALIGN","LITTLE_ENDIAN_BYTE_ALIGN","IDF_ENTRY_BYTES","NUM_DIRECTORY_ENTRIES_BYTES","isEXIF","buffer","toString","extractSize","index","height","readUInt16BE","width","extractOrientation","exifBlock","isBigEndian","idfOffset","offset","idfDirectoryEntries","readUInt","directoryEntryNumber","start","end","length","block","slice","tagNumber","dataFormat","numberOfComponents","validateExifBlock","byteAlign","isLittleEndian","validateBuffer","TypeError","validate","SOIMarker","calculate","orientation","next","i","size"],"sources":["/Users/admin/project/redichan_frontend/node_modules/image-size/dist/types/jpg.js"],"sourcesContent":["\"use strict\";\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JPG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n// Each entry is exactly 12 bytes\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(buffer) {\n    return (buffer.toString('hex', 2, 6) === EXIF_MARKER);\n}\nfunction extractSize(buffer, index) {\n    return {\n        height: buffer.readUInt16BE(index),\n        width: buffer.readUInt16BE(index + 2)\n    };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n    // TODO: assert that this contains 0x002A\n    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n    const idfOffset = 8;\n    // IDF osset works from right after the header bytes\n    // (so the offset includes the tiff byte align)\n    const offset = EXIF_HEADER_BYTES + idfOffset;\n    const idfDirectoryEntries = (0, readUInt_1.readUInt)(exifBlock, 16, offset, isBigEndian);\n    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + (directoryEntryNumber * IDF_ENTRY_BYTES);\n        const end = start + IDF_ENTRY_BYTES;\n        // Skip on corrupt EXIF blocks\n        if (start > exifBlock.length) {\n            return;\n        }\n        const block = exifBlock.slice(start, end);\n        const tagNumber = (0, readUInt_1.readUInt)(block, 16, 0, isBigEndian);\n        // 0x0112 (decimal: 274) is the `orientation` tag ID\n        if (tagNumber === 274) {\n            const dataFormat = (0, readUInt_1.readUInt)(block, 16, 2, isBigEndian);\n            if (dataFormat !== 3) {\n                return;\n            }\n            // unsinged int has 2 bytes per component\n            // if there would more than 4 bytes in total it's a pointer\n            const numberOfComponents = (0, readUInt_1.readUInt)(block, 32, 4, isBigEndian);\n            if (numberOfComponents !== 1) {\n                return;\n            }\n            return (0, readUInt_1.readUInt)(block, 16, 8, isBigEndian);\n        }\n    }\n}\nfunction validateExifBlock(buffer, index) {\n    // Skip APP1 Data Size\n    const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);\n    // Consider byte alignment\n    const byteAlign = exifBlock.toString('hex', EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n    // Ignore Empty EXIF. Validate byte alignment\n    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n    if (isBigEndian || isLittleEndian) {\n        return extractOrientation(exifBlock, isBigEndian);\n    }\n}\nfunction validateBuffer(buffer, index) {\n    // index should be within buffer limits\n    if (index > buffer.length) {\n        throw new TypeError('Corrupt JPG, exceeded buffer limits');\n    }\n    // Every JPEG block must begin with a 0xFF\n    if (buffer[index] !== 0xFF) {\n        throw new TypeError('Invalid JPG, marker table corrupted');\n    }\n}\nexports.JPG = {\n    validate(buffer) {\n        const SOIMarker = buffer.toString('hex', 0, 2);\n        return ('ffd8' === SOIMarker);\n    },\n    calculate(buffer) {\n        // Skip 4 chars, they are for signature\n        buffer = buffer.slice(4);\n        let orientation;\n        let next;\n        while (buffer.length) {\n            // read length of the next block\n            const i = buffer.readUInt16BE(0);\n            if (isEXIF(buffer)) {\n                orientation = validateExifBlock(buffer, i);\n            }\n            // ensure correct format\n            validateBuffer(buffer, i);\n            // 0xFFC0 is baseline standard(SOF)\n            // 0xFFC1 is baseline optimized(SOF)\n            // 0xFFC2 is progressive(SOF2)\n            next = buffer[i + 1];\n            if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n                const size = extractSize(buffer, i + 5);\n                // TODO: is orientation=0 a valid answer here?\n                if (!orientation) {\n                    return size;\n                }\n                return {\n                    height: size.height,\n                    orientation,\n                    width: size.width\n                };\n            }\n            // move to the next block\n            buffer = buffer.slice(i + 2);\n        }\n        throw new TypeError('Invalid JPG, no size found');\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}