{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ICNS = void 0;\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n */\nconst SIZE_HEADER = 4 + 4; // 8\nconst FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n */\nconst ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\nconst ICON_TYPE_SIZE = {\n  ICON: 32,\n  'ICN#': 32,\n  // m => 16 x 16\n  'icm#': 16,\n  icm4: 16,\n  icm8: 16,\n  // s => 16 x 16\n  'ics#': 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  // l => 32 x 32\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  // h => 48 x 48\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  // . => 64 x 64\n  icp6: 64,\n  ic12: 32,\n  // t => 128 x 128\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  // . => 256 x 256\n  ic08: 256,\n  ic13: 256,\n  // . => 512 x 512\n  ic09: 512,\n  ic14: 512,\n  // . => 1024 x 1024\n  ic10: 1024\n};\nfunction readImageHeader(buffer, imageOffset) {\n  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n  return [buffer.toString('ascii', imageOffset, imageLengthOffset), buffer.readUInt32BE(imageLengthOffset)];\n}\nfunction getImageSize(type) {\n  const size = ICON_TYPE_SIZE[type];\n  return {\n    width: size,\n    height: size,\n    type\n  };\n}\nexports.ICNS = {\n  validate(buffer) {\n    return 'icns' === buffer.toString('ascii', 0, 4);\n  },\n  calculate(buffer) {\n    const bufferLength = buffer.length;\n    const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);\n    let imageOffset = SIZE_HEADER;\n    let imageHeader = readImageHeader(buffer, imageOffset);\n    let imageSize = getImageSize(imageHeader[0]);\n    imageOffset += imageHeader[1];\n    if (imageOffset === fileLength) {\n      return imageSize;\n    }\n    const result = {\n      height: imageSize.height,\n      images: [imageSize],\n      width: imageSize.width\n    };\n    while (imageOffset < fileLength && imageOffset < bufferLength) {\n      imageHeader = readImageHeader(buffer, imageOffset);\n      imageSize = getImageSize(imageHeader[0]);\n      imageOffset += imageHeader[1];\n      result.images.push(imageSize);\n    }\n    return result;\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","ICNS","SIZE_HEADER","FILE_LENGTH_OFFSET","ENTRY_LENGTH_OFFSET","ICON_TYPE_SIZE","ICON","icm4","icm8","ics4","ics8","is32","s8mk","icp4","icl4","icl8","il32","l8mk","icp5","ic11","ich4","ich8","ih32","h8mk","icp6","ic12","it32","t8mk","ic07","ic08","ic13","ic09","ic14","ic10","readImageHeader","buffer","imageOffset","imageLengthOffset","toString","readUInt32BE","getImageSize","type","size","width","height","validate","calculate","bufferLength","length","fileLength","imageHeader","imageSize","result","images","push"],"sources":["/Users/admin/project/redichan_frontend/node_modules/image-size/dist/types/icns.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICNS = void 0;\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n */\nconst SIZE_HEADER = 4 + 4; // 8\nconst FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n */\nconst ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\nconst ICON_TYPE_SIZE = {\n    ICON: 32,\n    'ICN#': 32,\n    // m => 16 x 16\n    'icm#': 16,\n    icm4: 16,\n    icm8: 16,\n    // s => 16 x 16\n    'ics#': 16,\n    ics4: 16,\n    ics8: 16,\n    is32: 16,\n    s8mk: 16,\n    icp4: 16,\n    // l => 32 x 32\n    icl4: 32,\n    icl8: 32,\n    il32: 32,\n    l8mk: 32,\n    icp5: 32,\n    ic11: 32,\n    // h => 48 x 48\n    ich4: 48,\n    ich8: 48,\n    ih32: 48,\n    h8mk: 48,\n    // . => 64 x 64\n    icp6: 64,\n    ic12: 32,\n    // t => 128 x 128\n    it32: 128,\n    t8mk: 128,\n    ic07: 128,\n    // . => 256 x 256\n    ic08: 256,\n    ic13: 256,\n    // . => 512 x 512\n    ic09: 512,\n    ic14: 512,\n    // . => 1024 x 1024\n    ic10: 1024,\n};\nfunction readImageHeader(buffer, imageOffset) {\n    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n    return [\n        buffer.toString('ascii', imageOffset, imageLengthOffset),\n        buffer.readUInt32BE(imageLengthOffset)\n    ];\n}\nfunction getImageSize(type) {\n    const size = ICON_TYPE_SIZE[type];\n    return { width: size, height: size, type };\n}\nexports.ICNS = {\n    validate(buffer) {\n        return ('icns' === buffer.toString('ascii', 0, 4));\n    },\n    calculate(buffer) {\n        const bufferLength = buffer.length;\n        const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);\n        let imageOffset = SIZE_HEADER;\n        let imageHeader = readImageHeader(buffer, imageOffset);\n        let imageSize = getImageSize(imageHeader[0]);\n        imageOffset += imageHeader[1];\n        if (imageOffset === fileLength) {\n            return imageSize;\n        }\n        const result = {\n            height: imageSize.height,\n            images: [imageSize],\n            width: imageSize.width\n        };\n        while (imageOffset < fileLength && imageOffset < bufferLength) {\n            imageHeader = readImageHeader(buffer, imageOffset);\n            imageSize = getImageSize(imageHeader[0]);\n            imageOffset += imageHeader[1];\n            result.images.push(imageSize);\n        }\n        return result;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}