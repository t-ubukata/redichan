{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst stream = require('stream');\nconst sizeOf = require('image-size');\nconst sharp = require('sharp');\nconst validator = require('validator');\nconst axios = require('axios');\nconst util = require('./util');\nconst {\n  fail\n} = require('assert');\nconst PERCENTAGE = 10;\nconst RESPONSE_TYPE = 'buffer';\nconst fromBase64 = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n  const imageBuffer = Buffer.from(source, 'base64');\n  const dimensions = getDimensions(imageBuffer, percentage, {\n    width,\n    height\n  });\n  const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n  if (responseType === 'base64') {\n    return thumbnailBuffer.toString('base64');\n  }\n  return thumbnailBuffer;\n};\nconst fromUri = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n  const response = await axios.get(source.uri, {\n    responseType: 'arraybuffer'\n  });\n  const imageBuffer = Buffer.from(response.data, 'binary');\n  const dimensions = getDimensions(imageBuffer, percentage, {\n    width,\n    height\n  });\n  const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n  if (responseType === 'base64') {\n    return thumbnailBuffer.toString('base64');\n  }\n  return thumbnailBuffer;\n};\nconst fromPath = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n  const imageBuffer = fs.readFileSync(source);\n  const dimensions = getDimensions(imageBuffer, percentage, {\n    width,\n    height\n  });\n  const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n  if (responseType === 'base64') {\n    return thumbnailBuffer.toString('base64');\n  }\n  return thumbnailBuffer;\n};\nconst fromReadStream = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n  const imageBuffer = await util.streamToBuffer(source);\n  const dimensions = getDimensions(imageBuffer, percentage, {\n    width,\n    height\n  });\n  const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n  if (responseType === 'base64') {\n    return thumbnailBuffer.toString('base64');\n  }\n  return thumbnailBuffer;\n};\nconst fromBuffer = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n  const imageBuffer = source;\n  const dimensions = getDimensions(imageBuffer, percentage, {\n    width,\n    height\n  });\n  const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n  if (responseType === 'base64') {\n    return thumbnailBuffer.toString('base64');\n  }\n  return thumbnailBuffer;\n};\nmodule.exports = async (source, options) => {\n  const percentage = options && options.percentage ? options.percentage : PERCENTAGE;\n  const width = options && options.width ? options.width : undefined;\n  const height = options && options.height ? options.height : undefined;\n  const responseType = options && options.responseType ? options.responseType : RESPONSE_TYPE;\n  const jpegOptions = options && options.jpegOptions ? options.jpegOptions : undefined;\n  const fit = options && options.fit ? options.fit : undefined;\n  const failOnError = options && typeof options.failOnError !== 'undefined' ? options.failOnError : true;\n  const withMetaData = options && typeof options.withMetaData !== 'undefined' ? options.withMetaData : false;\n  try {\n    switch (typeof source) {\n      case 'object':\n        let response;\n        if (source instanceof fs.ReadStream || source instanceof stream.PassThrough) {\n          response = await fromReadStream(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n        } else if (source instanceof Buffer) {\n          response = await fromBuffer(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n        } else {\n          response = await fromUri(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n        }\n        return response;\n      case 'string':\n        if (validator.isBase64(source)) {\n          return await fromBase64(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n        } else {\n          return await fromPath(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n        }\n      default:\n        throw new Error('unsupported source type');\n    }\n  } catch (err) {\n    throw new Error(err.message);\n  }\n};\nconst getDimensions = (imageBuffer, percentageOfImage, dimensions) => {\n  if (typeof dimensions.width != 'undefined' || typeof dimensions.height != 'undefined') {\n    return util.removeUndefined(dimensions);\n  }\n  const originalDimensions = sizeOf(imageBuffer);\n  const width = parseInt((originalDimensions.width * (percentageOfImage / 100)).toFixed(0));\n  const height = parseInt((originalDimensions.height * (percentageOfImage / 100)).toFixed(0));\n  return {\n    width,\n    height\n  };\n};\nconst sharpResize = (imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetadata) => {\n  return new Promise((resolve, reject) => {\n    let result = sharp(imageBuffer, {\n      failOnError\n    }).resize({\n      ...dimensions,\n      withoutEnlargement: true,\n      fit: fit ? fit : 'contain'\n    });\n    if (withMetadata) {\n      result.withMetadata();\n    }\n    result.jpeg(jpegOptions ? jpegOptions : {\n      force: false\n    }).toBuffer((err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n};","map":{"version":3,"names":["fs","require","stream","sizeOf","sharp","validator","axios","util","fail","PERCENTAGE","RESPONSE_TYPE","fromBase64","source","percentage","width","height","responseType","jpegOptions","fit","failOnError","withMetaData","imageBuffer","Buffer","from","dimensions","getDimensions","thumbnailBuffer","sharpResize","toString","fromUri","response","get","uri","data","fromPath","readFileSync","fromReadStream","streamToBuffer","fromBuffer","module","exports","options","undefined","ReadStream","PassThrough","isBase64","Error","err","message","percentageOfImage","removeUndefined","originalDimensions","parseInt","toFixed","withMetadata","Promise","resolve","reject","result","resize","withoutEnlargement","jpeg","force","toBuffer"],"sources":["/Users/admin/project/redichan_frontend/node_modules/image-thumbnail/src/index.js"],"sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst stream = require('stream');\nconst sizeOf = require('image-size');\nconst sharp = require('sharp');\nconst validator = require('validator');\nconst axios = require('axios');\nconst util = require('./util');\nconst { fail } = require('assert');\n\nconst PERCENTAGE = 10;\nconst RESPONSE_TYPE = 'buffer';\n\nconst fromBase64 = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n    const imageBuffer = Buffer.from(source, 'base64');\n    const dimensions = getDimensions(imageBuffer, percentage, { width, height });\n    const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n\n    if (responseType === 'base64') {\n        return thumbnailBuffer.toString('base64');\n    }\n\n    return thumbnailBuffer;\n};\n\nconst fromUri = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n    const response = await axios.get(source.uri, { responseType: 'arraybuffer' });\n    const imageBuffer = Buffer.from(response.data, 'binary');\n\n    const dimensions = getDimensions(imageBuffer, percentage, { width, height });\n    const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n\n\n    if (responseType === 'base64') {\n        return thumbnailBuffer.toString('base64');\n    }\n\n    return thumbnailBuffer;\n};\n\nconst fromPath = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n    const imageBuffer = fs.readFileSync(source);\n\n    const dimensions = getDimensions(imageBuffer, percentage, { width, height });\n    const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n\n    if (responseType === 'base64') {\n        return thumbnailBuffer.toString('base64');\n    }\n\n    return thumbnailBuffer;\n};\n\nconst fromReadStream = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n    const imageBuffer = await util.streamToBuffer(source);\n    const dimensions = getDimensions(imageBuffer, percentage, { width, height });\n    const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n\n    if (responseType === 'base64') {\n        return thumbnailBuffer.toString('base64');\n    }\n\n    return thumbnailBuffer;\n};\n\nconst fromBuffer = async (source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData) => {\n    const imageBuffer = source;\n\n    const dimensions = getDimensions(imageBuffer, percentage, { width, height });\n    const thumbnailBuffer = await sharpResize(imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetaData);\n\n    if (responseType === 'base64') {\n        return thumbnailBuffer.toString('base64');\n    }\n\n    return thumbnailBuffer;\n};\n\nmodule.exports = async (source, options) => {\n    const percentage = options && options.percentage ? options.percentage : PERCENTAGE;\n    const width = options && options.width ? options.width : undefined;\n    const height = options && options.height ? options.height : undefined;\n    const responseType = options && options.responseType ? options.responseType : RESPONSE_TYPE;\n    const jpegOptions = options && options.jpegOptions ? options.jpegOptions : undefined;\n    const fit = options && options.fit ? options.fit : undefined;\n    const failOnError = options && typeof(options.failOnError) !== 'undefined' ? options.failOnError : true;\n    const withMetaData = options && typeof(options.withMetaData) !== 'undefined' ? options.withMetaData : false;\n\n    try {\n        switch (typeof source) {\n            case 'object':\n                let response;\n                if (source instanceof fs.ReadStream || source instanceof stream.PassThrough) {\n                    response = await fromReadStream(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n                } else if (source instanceof Buffer) {\n                    response = await fromBuffer(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n                } else {\n                    response = await fromUri(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n                }\n                return response;\n            case 'string':\n                if (validator.isBase64(source)) {\n                    return await fromBase64(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n                } else {\n                    return await fromPath(source, percentage, width, height, responseType, jpegOptions, fit, failOnError, withMetaData);\n                }\n            default:\n                throw new Error('unsupported source type');\n        }\n    } catch (err) {\n        throw new Error(err.message);\n    }\n};\n\nconst getDimensions = (imageBuffer, percentageOfImage, dimensions) => {\n    if (typeof dimensions.width != 'undefined' || typeof dimensions.height != 'undefined') {\n        return util.removeUndefined(dimensions);\n    }\n\n    const originalDimensions = sizeOf(imageBuffer);\n\n    const width = parseInt((originalDimensions.width * (percentageOfImage / 100)).toFixed(0));\n    const height = parseInt((originalDimensions.height * (percentageOfImage / 100)).toFixed(0));\n\n    return { width, height };\n}\n\nconst sharpResize = (imageBuffer, dimensions, jpegOptions, fit, failOnError, withMetadata) => {\n    return new Promise((resolve, reject) => {\n        let result = sharp(imageBuffer, { failOnError })\n            .resize({\n                ...dimensions, withoutEnlargement: true, fit: fit ? fit : 'contain',\n            })\n\n            if(withMetadata){\n              result.withMetadata()\n            }\n\n            result.jpeg(jpegOptions ? jpegOptions : { force: false })\n            .toBuffer((err, data) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(data);\n                }\n            });\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}