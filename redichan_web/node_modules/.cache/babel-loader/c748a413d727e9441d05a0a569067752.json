{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TIFF = void 0;\n// based on http://www.compix.com/fileformattif.htm\n// TO-DO: support big-endian as well\nconst fs = require(\"fs\");\nconst readUInt_1 = require(\"../readUInt\");\n// Read IFD (image-file-directory) into a buffer\nfunction readIFD(buffer, filepath, isBigEndian) {\n  const ifdOffset = (0, readUInt_1.readUInt)(buffer, 32, 4, isBigEndian);\n  // read only till the end of the file\n  let bufferSize = 1024;\n  const fileSize = fs.statSync(filepath).size;\n  if (ifdOffset + bufferSize > fileSize) {\n    bufferSize = fileSize - ifdOffset - 10;\n  }\n  // populate the buffer\n  const endBuffer = Buffer.alloc(bufferSize);\n  const descriptor = fs.openSync(filepath, 'r');\n  fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);\n  fs.closeSync(descriptor);\n  return endBuffer.slice(2);\n}\n// TIFF values seem to be messed up on Big-Endian, this helps\nfunction readValue(buffer, isBigEndian) {\n  const low = (0, readUInt_1.readUInt)(buffer, 16, 8, isBigEndian);\n  const high = (0, readUInt_1.readUInt)(buffer, 16, 10, isBigEndian);\n  return (high << 16) + low;\n}\n// move to the next tag\nfunction nextTag(buffer) {\n  if (buffer.length > 24) {\n    return buffer.slice(12);\n  }\n}\n// Extract IFD tags from TIFF metadata\nfunction extractTags(buffer, isBigEndian) {\n  const tags = {};\n  let temp = buffer;\n  while (temp && temp.length) {\n    const code = (0, readUInt_1.readUInt)(temp, 16, 0, isBigEndian);\n    const type = (0, readUInt_1.readUInt)(temp, 16, 2, isBigEndian);\n    const length = (0, readUInt_1.readUInt)(temp, 32, 4, isBigEndian);\n    // 0 means end of IFD\n    if (code === 0) {\n      break;\n    } else {\n      // 256 is width, 257 is height\n      // if (code === 256 || code === 257) {\n      if (length === 1 && (type === 3 || type === 4)) {\n        tags[code] = readValue(temp, isBigEndian);\n      }\n      // move to the next tag\n      temp = nextTag(temp);\n    }\n  }\n  return tags;\n}\n// Test if the TIFF is Big Endian or Little Endian\nfunction determineEndianness(buffer) {\n  const signature = buffer.toString('ascii', 0, 2);\n  if ('II' === signature) {\n    return 'LE';\n  } else if ('MM' === signature) {\n    return 'BE';\n  }\n}\nconst signatures = [\n// '492049', // currently not supported\n'49492a00', '4d4d002a' // Big Endian\n// '4d4d002a', // BigTIFF > 4GB. currently not supported\n];\n\nexports.TIFF = {\n  validate(buffer) {\n    return signatures.includes(buffer.toString('hex', 0, 4));\n  },\n  calculate(buffer, filepath) {\n    if (!filepath) {\n      throw new TypeError('Tiff doesn\\'t support buffer');\n    }\n    // Determine BE/LE\n    const isBigEndian = determineEndianness(buffer) === 'BE';\n    // read the IFD\n    const ifdBuffer = readIFD(buffer, filepath, isBigEndian);\n    // extract the tags from the IFD\n    const tags = extractTags(ifdBuffer, isBigEndian);\n    const width = tags[256];\n    const height = tags[257];\n    if (!width || !height) {\n      throw new TypeError('Invalid Tiff. Missing tags');\n    }\n    return {\n      height,\n      width\n    };\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","TIFF","fs","require","readUInt_1","readIFD","buffer","filepath","isBigEndian","ifdOffset","readUInt","bufferSize","fileSize","statSync","size","endBuffer","Buffer","alloc","descriptor","openSync","readSync","closeSync","slice","readValue","low","high","nextTag","length","extractTags","tags","temp","code","type","determineEndianness","signature","toString","signatures","validate","includes","calculate","TypeError","ifdBuffer","width","height"],"sources":["/Users/admin/project/redichan_frontend/node_modules/image-size/dist/types/tiff.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TIFF = void 0;\n// based on http://www.compix.com/fileformattif.htm\n// TO-DO: support big-endian as well\nconst fs = require(\"fs\");\nconst readUInt_1 = require(\"../readUInt\");\n// Read IFD (image-file-directory) into a buffer\nfunction readIFD(buffer, filepath, isBigEndian) {\n    const ifdOffset = (0, readUInt_1.readUInt)(buffer, 32, 4, isBigEndian);\n    // read only till the end of the file\n    let bufferSize = 1024;\n    const fileSize = fs.statSync(filepath).size;\n    if (ifdOffset + bufferSize > fileSize) {\n        bufferSize = fileSize - ifdOffset - 10;\n    }\n    // populate the buffer\n    const endBuffer = Buffer.alloc(bufferSize);\n    const descriptor = fs.openSync(filepath, 'r');\n    fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);\n    fs.closeSync(descriptor);\n    return endBuffer.slice(2);\n}\n// TIFF values seem to be messed up on Big-Endian, this helps\nfunction readValue(buffer, isBigEndian) {\n    const low = (0, readUInt_1.readUInt)(buffer, 16, 8, isBigEndian);\n    const high = (0, readUInt_1.readUInt)(buffer, 16, 10, isBigEndian);\n    return (high << 16) + low;\n}\n// move to the next tag\nfunction nextTag(buffer) {\n    if (buffer.length > 24) {\n        return buffer.slice(12);\n    }\n}\n// Extract IFD tags from TIFF metadata\nfunction extractTags(buffer, isBigEndian) {\n    const tags = {};\n    let temp = buffer;\n    while (temp && temp.length) {\n        const code = (0, readUInt_1.readUInt)(temp, 16, 0, isBigEndian);\n        const type = (0, readUInt_1.readUInt)(temp, 16, 2, isBigEndian);\n        const length = (0, readUInt_1.readUInt)(temp, 32, 4, isBigEndian);\n        // 0 means end of IFD\n        if (code === 0) {\n            break;\n        }\n        else {\n            // 256 is width, 257 is height\n            // if (code === 256 || code === 257) {\n            if (length === 1 && (type === 3 || type === 4)) {\n                tags[code] = readValue(temp, isBigEndian);\n            }\n            // move to the next tag\n            temp = nextTag(temp);\n        }\n    }\n    return tags;\n}\n// Test if the TIFF is Big Endian or Little Endian\nfunction determineEndianness(buffer) {\n    const signature = buffer.toString('ascii', 0, 2);\n    if ('II' === signature) {\n        return 'LE';\n    }\n    else if ('MM' === signature) {\n        return 'BE';\n    }\n}\nconst signatures = [\n    // '492049', // currently not supported\n    '49492a00',\n    '4d4d002a', // Big Endian\n    // '4d4d002a', // BigTIFF > 4GB. currently not supported\n];\nexports.TIFF = {\n    validate(buffer) {\n        return signatures.includes(buffer.toString('hex', 0, 4));\n    },\n    calculate(buffer, filepath) {\n        if (!filepath) {\n            throw new TypeError('Tiff doesn\\'t support buffer');\n        }\n        // Determine BE/LE\n        const isBigEndian = determineEndianness(buffer) === 'BE';\n        // read the IFD\n        const ifdBuffer = readIFD(buffer, filepath, isBigEndian);\n        // extract the tags from the IFD\n        const tags = extractTags(ifdBuffer, isBigEndian);\n        const width = tags[256];\n        const height = tags[257];\n        if (!width || !height) {\n            throw new TypeError('Invalid Tiff. Missing tags');\n        }\n        return { height, width };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}