{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst queue_1 = require(\"queue\");\nconst types_1 = require(\"./types\");\nconst detector_1 = require(\"./detector\");\n// Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\nconst MaxBufferSize = 512 * 1024;\n// This queue is for async `fs` operations, to avoid reaching file-descriptor limits\nconst queue = new queue_1.default({\n  concurrency: 100,\n  autostart: true\n});\nconst globalOptions = {\n  disabledFS: false,\n  disabledTypes: []\n};\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\nfunction lookup(buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  const type = (0, detector_1.detector)(buffer);\n  if (typeof type !== 'undefined') {\n    if (globalOptions.disabledTypes.indexOf(type) > -1) {\n      throw new TypeError('disabled file type: ' + type);\n    }\n    // find an appropriate handler for this file type\n    if (type in types_1.typeHandlers) {\n      const size = types_1.typeHandlers[type].calculate(buffer, filepath);\n      if (size !== undefined) {\n        size.type = type;\n        return size;\n      }\n    }\n  }\n  // throw up, if we don't understand the file\n  throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n * @param {String} filepath\n * @returns {Promise<Buffer>}\n */\nasync function asyncFileToBuffer(filepath) {\n  const handle = await fs.promises.open(filepath, 'r');\n  try {\n    const {\n      size\n    } = await handle.stat();\n    if (size <= 0) {\n      throw new Error('Empty file');\n    }\n    const bufferSize = Math.min(size, MaxBufferSize);\n    const buffer = Buffer.alloc(bufferSize);\n    await handle.read(buffer, 0, bufferSize, 0);\n    return buffer;\n  } finally {\n    await handle.close();\n  }\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\nfunction syncFileToBuffer(filepath) {\n  // read from the file, synchronously\n  const descriptor = fs.openSync(filepath, 'r');\n  try {\n    const {\n      size\n    } = fs.fstatSync(descriptor);\n    if (size <= 0) {\n      throw new Error('Empty file');\n    }\n    const bufferSize = Math.min(size, MaxBufferSize);\n    const buffer = Buffer.alloc(bufferSize);\n    fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n    return buffer;\n  } finally {\n    fs.closeSync(descriptor);\n  }\n}\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nmodule.exports = exports = imageSize; // backwards compatibility\nexports.default = imageSize;\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} [callback] - optional function for async detection\n */\nfunction imageSize(input, callback) {\n  // Handle buffer input\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  }\n  // input should be a string at this point\n  if (typeof input !== 'string' || globalOptions.disabledFS) {\n    throw new TypeError('invalid invocation. input should be a Buffer');\n  }\n  // resolve the file path\n  const filepath = path.resolve(input);\n  if (typeof callback === 'function') {\n    queue.push(() => asyncFileToBuffer(filepath).then(buffer => process.nextTick(callback, null, lookup(buffer, filepath))).catch(callback));\n  } else {\n    const buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n}\nexports.imageSize = imageSize;\nconst disableFS = v => {\n  globalOptions.disabledFS = v;\n};\nexports.disableFS = disableFS;\nconst disableTypes = types => {\n  globalOptions.disabledTypes = types;\n};\nexports.disableTypes = disableTypes;\nconst setConcurrency = c => {\n  queue.concurrency = c;\n};\nexports.setConcurrency = setConcurrency;\nexports.types = Object.keys(types_1.typeHandlers);","map":{"version":3,"names":["Object","defineProperty","exports","value","types","setConcurrency","disableTypes","disableFS","imageSize","fs","require","path","queue_1","types_1","detector_1","MaxBufferSize","queue","default","concurrency","autostart","globalOptions","disabledFS","disabledTypes","lookup","buffer","filepath","type","detector","indexOf","TypeError","typeHandlers","size","calculate","undefined","asyncFileToBuffer","handle","promises","open","stat","Error","bufferSize","Math","min","Buffer","alloc","read","close","syncFileToBuffer","descriptor","openSync","fstatSync","readSync","closeSync","module","input","callback","isBuffer","resolve","push","then","process","nextTick","catch","v","c","keys"],"sources":["/Users/admin/project/redichan_frontend/node_modules/image-size/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst queue_1 = require(\"queue\");\nconst types_1 = require(\"./types\");\nconst detector_1 = require(\"./detector\");\n// Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\nconst MaxBufferSize = 512 * 1024;\n// This queue is for async `fs` operations, to avoid reaching file-descriptor limits\nconst queue = new queue_1.default({ concurrency: 100, autostart: true });\nconst globalOptions = {\n    disabledFS: false,\n    disabledTypes: []\n};\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\nfunction lookup(buffer, filepath) {\n    // detect the file type.. don't rely on the extension\n    const type = (0, detector_1.detector)(buffer);\n    if (typeof type !== 'undefined') {\n        if (globalOptions.disabledTypes.indexOf(type) > -1) {\n            throw new TypeError('disabled file type: ' + type);\n        }\n        // find an appropriate handler for this file type\n        if (type in types_1.typeHandlers) {\n            const size = types_1.typeHandlers[type].calculate(buffer, filepath);\n            if (size !== undefined) {\n                size.type = type;\n                return size;\n            }\n        }\n    }\n    // throw up, if we don't understand the file\n    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n * @param {String} filepath\n * @returns {Promise<Buffer>}\n */\nasync function asyncFileToBuffer(filepath) {\n    const handle = await fs.promises.open(filepath, 'r');\n    try {\n        const { size } = await handle.stat();\n        if (size <= 0) {\n            throw new Error('Empty file');\n        }\n        const bufferSize = Math.min(size, MaxBufferSize);\n        const buffer = Buffer.alloc(bufferSize);\n        await handle.read(buffer, 0, bufferSize, 0);\n        return buffer;\n    }\n    finally {\n        await handle.close();\n    }\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\nfunction syncFileToBuffer(filepath) {\n    // read from the file, synchronously\n    const descriptor = fs.openSync(filepath, 'r');\n    try {\n        const { size } = fs.fstatSync(descriptor);\n        if (size <= 0) {\n            throw new Error('Empty file');\n        }\n        const bufferSize = Math.min(size, MaxBufferSize);\n        const buffer = Buffer.alloc(bufferSize);\n        fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n        return buffer;\n    }\n    finally {\n        fs.closeSync(descriptor);\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nmodule.exports = exports = imageSize; // backwards compatibility\nexports.default = imageSize;\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} [callback] - optional function for async detection\n */\nfunction imageSize(input, callback) {\n    // Handle buffer input\n    if (Buffer.isBuffer(input)) {\n        return lookup(input);\n    }\n    // input should be a string at this point\n    if (typeof input !== 'string' || globalOptions.disabledFS) {\n        throw new TypeError('invalid invocation. input should be a Buffer');\n    }\n    // resolve the file path\n    const filepath = path.resolve(input);\n    if (typeof callback === 'function') {\n        queue.push(() => asyncFileToBuffer(filepath)\n            .then((buffer) => process.nextTick(callback, null, lookup(buffer, filepath)))\n            .catch(callback));\n    }\n    else {\n        const buffer = syncFileToBuffer(filepath);\n        return lookup(buffer, filepath);\n    }\n}\nexports.imageSize = imageSize;\nconst disableFS = (v) => { globalOptions.disabledFS = v; };\nexports.disableFS = disableFS;\nconst disableTypes = (types) => { globalOptions.disabledTypes = types; };\nexports.disableTypes = disableTypes;\nconst setConcurrency = (c) => { queue.concurrency = c; };\nexports.setConcurrency = setConcurrency;\nexports.types = Object.keys(types_1.typeHandlers);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}