{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ICO = void 0;\nconst TYPE_ICON = 1;\n/**\n * ICON Header\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 2    | Reserved. Must always be 0.  |\n * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |\n * | 4      | 2    | Number of images in the file. |\n *\n */\nconst SIZE_HEADER = 2 + 2 + 2; // 6\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |\n * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |\n * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |\n * | 3      | 1    | Reserved. Should be 0. |\n * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |\n * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |\n * | 6      | 2    | ICO format: Bits per pixel. |\n * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |\n * | 8      | 4    | The size of the image's data in bytes |\n * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |\n *\n */\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16\nfunction getSizeFromOffset(buffer, offset) {\n  const value = buffer.readUInt8(offset);\n  return value === 0 ? 256 : value;\n}\nfunction getImageSize(buffer, imageIndex) {\n  const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;\n  return {\n    height: getSizeFromOffset(buffer, offset + 1),\n    width: getSizeFromOffset(buffer, offset)\n  };\n}\nexports.ICO = {\n  validate(buffer) {\n    const reserved = buffer.readUInt16LE(0);\n    const imageCount = buffer.readUInt16LE(4);\n    if (reserved !== 0 || imageCount === 0) {\n      return false;\n    }\n    const imageType = buffer.readUInt16LE(2);\n    return imageType === TYPE_ICON;\n  },\n  calculate(buffer) {\n    const nbImages = buffer.readUInt16LE(4);\n    const imageSize = getImageSize(buffer, 0);\n    if (nbImages === 1) {\n      return imageSize;\n    }\n    const imgs = [imageSize];\n    for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n      imgs.push(getImageSize(buffer, imageIndex));\n    }\n    const result = {\n      height: imageSize.height,\n      images: imgs,\n      width: imageSize.width\n    };\n    return result;\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","ICO","TYPE_ICON","SIZE_HEADER","SIZE_IMAGE_ENTRY","getSizeFromOffset","buffer","offset","readUInt8","getImageSize","imageIndex","height","width","validate","reserved","readUInt16LE","imageCount","imageType","calculate","nbImages","imageSize","imgs","push","result","images"],"sources":["/Users/admin/project/redichan_frontend/node_modules/image-size/dist/types/ico.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICO = void 0;\nconst TYPE_ICON = 1;\n/**\n * ICON Header\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 2    | Reserved. Must always be 0.  |\n * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |\n * | 4      | 2    | Number of images in the file. |\n *\n */\nconst SIZE_HEADER = 2 + 2 + 2; // 6\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |\n * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |\n * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |\n * | 3      | 1    | Reserved. Should be 0. |\n * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |\n * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |\n * | 6      | 2    | ICO format: Bits per pixel. |\n * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |\n * | 8      | 4    | The size of the image's data in bytes |\n * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |\n *\n */\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16\nfunction getSizeFromOffset(buffer, offset) {\n    const value = buffer.readUInt8(offset);\n    return value === 0 ? 256 : value;\n}\nfunction getImageSize(buffer, imageIndex) {\n    const offset = SIZE_HEADER + (imageIndex * SIZE_IMAGE_ENTRY);\n    return {\n        height: getSizeFromOffset(buffer, offset + 1),\n        width: getSizeFromOffset(buffer, offset)\n    };\n}\nexports.ICO = {\n    validate(buffer) {\n        const reserved = buffer.readUInt16LE(0);\n        const imageCount = buffer.readUInt16LE(4);\n        if (reserved !== 0 || imageCount === 0) {\n            return false;\n        }\n        const imageType = buffer.readUInt16LE(2);\n        return imageType === TYPE_ICON;\n    },\n    calculate(buffer) {\n        const nbImages = buffer.readUInt16LE(4);\n        const imageSize = getImageSize(buffer, 0);\n        if (nbImages === 1) {\n            return imageSize;\n        }\n        const imgs = [imageSize];\n        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n            imgs.push(getImageSize(buffer, imageIndex));\n        }\n        const result = {\n            height: imageSize.height,\n            images: imgs,\n            width: imageSize.width\n        };\n        return result;\n    }\n};\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,GAAG,GAAG,KAAK,CAAC;AACpB,MAAMC,SAAS,GAAG,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AACxD,SAASC,iBAAiB,CAACC,MAAM,EAAEC,MAAM,EAAE;EACvC,MAAMP,KAAK,GAAGM,MAAM,CAACE,SAAS,CAACD,MAAM,CAAC;EACtC,OAAOP,KAAK,KAAK,CAAC,GAAG,GAAG,GAAGA,KAAK;AACpC;AACA,SAASS,YAAY,CAACH,MAAM,EAAEI,UAAU,EAAE;EACtC,MAAMH,MAAM,GAAGJ,WAAW,GAAIO,UAAU,GAAGN,gBAAiB;EAC5D,OAAO;IACHO,MAAM,EAAEN,iBAAiB,CAACC,MAAM,EAAEC,MAAM,GAAG,CAAC,CAAC;IAC7CK,KAAK,EAAEP,iBAAiB,CAACC,MAAM,EAAEC,MAAM;EAC3C,CAAC;AACL;AACAR,OAAO,CAACE,GAAG,GAAG;EACVY,QAAQ,CAACP,MAAM,EAAE;IACb,MAAMQ,QAAQ,GAAGR,MAAM,CAACS,YAAY,CAAC,CAAC,CAAC;IACvC,MAAMC,UAAU,GAAGV,MAAM,CAACS,YAAY,CAAC,CAAC,CAAC;IACzC,IAAID,QAAQ,KAAK,CAAC,IAAIE,UAAU,KAAK,CAAC,EAAE;MACpC,OAAO,KAAK;IAChB;IACA,MAAMC,SAAS,GAAGX,MAAM,CAACS,YAAY,CAAC,CAAC,CAAC;IACxC,OAAOE,SAAS,KAAKf,SAAS;EAClC,CAAC;EACDgB,SAAS,CAACZ,MAAM,EAAE;IACd,MAAMa,QAAQ,GAAGb,MAAM,CAACS,YAAY,CAAC,CAAC,CAAC;IACvC,MAAMK,SAAS,GAAGX,YAAY,CAACH,MAAM,EAAE,CAAC,CAAC;IACzC,IAAIa,QAAQ,KAAK,CAAC,EAAE;MAChB,OAAOC,SAAS;IACpB;IACA,MAAMC,IAAI,GAAG,CAACD,SAAS,CAAC;IACxB,KAAK,IAAIV,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGS,QAAQ,EAAET,UAAU,IAAI,CAAC,EAAE;MAC7DW,IAAI,CAACC,IAAI,CAACb,YAAY,CAACH,MAAM,EAAEI,UAAU,CAAC,CAAC;IAC/C;IACA,MAAMa,MAAM,GAAG;MACXZ,MAAM,EAAES,SAAS,CAACT,MAAM;MACxBa,MAAM,EAAEH,IAAI;MACZT,KAAK,EAAEQ,SAAS,CAACR;IACrB,CAAC;IACD,OAAOW,MAAM;EACjB;AACJ,CAAC"},"metadata":{},"sourceType":"script"}