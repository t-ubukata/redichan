{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JP2 = void 0;\nconst BoxTypes = {\n  ftyp: '66747970',\n  ihdr: '69686472',\n  jp2h: '6a703268',\n  jp__: '6a502020',\n  rreq: '72726571',\n  xml_: '786d6c20'\n};\nconst calculateRREQLength = box => {\n  const unit = box.readUInt8(0);\n  let offset = 1 + 2 * unit;\n  const numStdFlags = box.readUInt16BE(offset);\n  const flagsLength = numStdFlags * (2 + unit);\n  offset = offset + 2 + flagsLength;\n  const numVendorFeatures = box.readUInt16BE(offset);\n  const featuresLength = numVendorFeatures * (16 + unit);\n  return offset + 2 + featuresLength;\n};\nconst parseIHDR = box => {\n  return {\n    height: box.readUInt32BE(4),\n    width: box.readUInt32BE(8)\n  };\n};\nexports.JP2 = {\n  validate(buffer) {\n    const signature = buffer.toString('hex', 4, 8);\n    const signatureLength = buffer.readUInt32BE(0);\n    if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n      return false;\n    }\n    const ftypeBoxStart = signatureLength + 4;\n    const ftypBoxLength = buffer.readUInt32BE(signatureLength);\n    const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n    return ftypBox.toString('hex', 0, 4) === BoxTypes.ftyp;\n  },\n  calculate(buffer) {\n    const signatureLength = buffer.readUInt32BE(0);\n    const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);\n    let offset = signatureLength + 4 + ftypBoxLength;\n    const nextBoxType = buffer.toString('hex', offset, offset + 4);\n    switch (nextBoxType) {\n      case BoxTypes.rreq:\n        // WHAT ARE THESE 4 BYTES?????\n        // eslint-disable-next-line no-case-declarations\n        const MAGIC = 4;\n        offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n      case BoxTypes.jp2h:\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n      default:\n        throw new TypeError('Unsupported header found: ' + buffer.toString('ascii', offset, offset + 4));\n    }\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","JP2","BoxTypes","ftyp","ihdr","jp2h","jp__","rreq","xml_","calculateRREQLength","box","unit","readUInt8","offset","numStdFlags","readUInt16BE","flagsLength","numVendorFeatures","featuresLength","parseIHDR","height","readUInt32BE","width","validate","buffer","signature","toString","signatureLength","ftypeBoxStart","ftypBoxLength","ftypBox","slice","calculate","nextBoxType","MAGIC","TypeError"],"sources":["/Users/admin/project/redichan_frontend/node_modules/image-size/dist/types/jp2.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JP2 = void 0;\nconst BoxTypes = {\n    ftyp: '66747970',\n    ihdr: '69686472',\n    jp2h: '6a703268',\n    jp__: '6a502020',\n    rreq: '72726571',\n    xml_: '786d6c20'\n};\nconst calculateRREQLength = (box) => {\n    const unit = box.readUInt8(0);\n    let offset = 1 + (2 * unit);\n    const numStdFlags = box.readUInt16BE(offset);\n    const flagsLength = numStdFlags * (2 + unit);\n    offset = offset + 2 + flagsLength;\n    const numVendorFeatures = box.readUInt16BE(offset);\n    const featuresLength = numVendorFeatures * (16 + unit);\n    return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box) => {\n    return {\n        height: box.readUInt32BE(4),\n        width: box.readUInt32BE(8),\n    };\n};\nexports.JP2 = {\n    validate(buffer) {\n        const signature = buffer.toString('hex', 4, 8);\n        const signatureLength = buffer.readUInt32BE(0);\n        if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n            return false;\n        }\n        const ftypeBoxStart = signatureLength + 4;\n        const ftypBoxLength = buffer.readUInt32BE(signatureLength);\n        const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n        return ftypBox.toString('hex', 0, 4) === BoxTypes.ftyp;\n    },\n    calculate(buffer) {\n        const signatureLength = buffer.readUInt32BE(0);\n        const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);\n        let offset = signatureLength + 4 + ftypBoxLength;\n        const nextBoxType = buffer.toString('hex', offset, offset + 4);\n        switch (nextBoxType) {\n            case BoxTypes.rreq:\n                // WHAT ARE THESE 4 BYTES?????\n                // eslint-disable-next-line no-case-declarations\n                const MAGIC = 4;\n                offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));\n                return parseIHDR(buffer.slice(offset + 8, offset + 24));\n            case BoxTypes.jp2h:\n                return parseIHDR(buffer.slice(offset + 8, offset + 24));\n            default:\n                throw new TypeError('Unsupported header found: ' + buffer.toString('ascii', offset, offset + 4));\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}