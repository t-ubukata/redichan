{"ast":null,"code":"'use strict';\n\nconst is = require('./is');\n\n/**\n * Boolean operations for bandbool.\n * @private\n */\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * See also {@link /api-operation#flatten|flatten}.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction removeAlpha() {\n  this.options.removeAlpha = true;\n  return this;\n}\n\n/**\n * Ensure the output image has an alpha transparency channel.\n * If missing, the added alpha channel will have the specified\n * transparency level, defaulting to fully-opaque (1).\n * This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * // rgba.png will be a 4 channel image with a fully-opaque alpha channel\n * await sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png')\n *\n * @example\n * // rgba is a 4 channel image with a fully-transparent alpha channel\n * const rgba = await sharp(rgb)\n *   .ensureAlpha(0)\n *   .toBuffer();\n *\n * @param {number} [alpha=1] - alpha transparency level (0=fully-transparent, 1=fully-opaque)\n * @returns {Sharp}\n * @throws {Error} Invalid alpha transparency level\n */\nfunction ensureAlpha(alpha) {\n  if (is.defined(alpha)) {\n    if (is.number(alpha) && is.inRange(alpha, 0, 1)) {\n      this.options.ensureAlpha = alpha;\n    } else {\n      throw is.invalidParameterError('alpha', 'number between 0 and 1', alpha);\n    }\n  } else {\n    this.options.ensureAlpha = 1;\n  }\n  return this;\n}\n\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * // green.jpg is a greyscale image containing the green channel of the input\n * await sharp(input)\n *   .extractChannel('green')\n *   .toFile('green.jpg');\n *\n * @example\n * // red1 is the red value of the first pixel, red2 the second pixel etc.\n * const [red1, red2, ...] = await sharp(input)\n *   .extractChannel(0)\n *   .raw()\n *   .toBuffer();\n *\n * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\nfunction extractChannel(channel) {\n  const channelMap = {\n    red: 0,\n    green: 1,\n    blue: 2,\n    alpha: 3\n  };\n  if (Object.keys(channelMap).includes(channel)) {\n    channel = channelMap[channel];\n  }\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);\n  }\n  return this.toColourspace('b-w');\n}\n\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction joinChannel(images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction bandbool(boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  });\n  // Class attributes\n  Sharp.bool = bool;\n};","map":{"version":3,"names":["is","require","bool","and","or","eor","removeAlpha","options","ensureAlpha","alpha","defined","number","inRange","invalidParameterError","extractChannel","channel","channelMap","red","green","blue","Object","keys","includes","integer","toColourspace","joinChannel","images","Array","isArray","forEach","image","joinChannelIn","push","_createInputDescriptor","bandbool","boolOp","string","inArray","bandBoolOp","module","exports","Sharp","assign","prototype"],"sources":["/Users/admin/project/redichan_frontend/node_modules/sharp/lib/channel.js"],"sourcesContent":["'use strict';\n\nconst is = require('./is');\n\n/**\n * Boolean operations for bandbool.\n * @private\n */\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * See also {@link /api-operation#flatten|flatten}.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction removeAlpha () {\n  this.options.removeAlpha = true;\n  return this;\n}\n\n/**\n * Ensure the output image has an alpha transparency channel.\n * If missing, the added alpha channel will have the specified\n * transparency level, defaulting to fully-opaque (1).\n * This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * // rgba.png will be a 4 channel image with a fully-opaque alpha channel\n * await sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png')\n *\n * @example\n * // rgba is a 4 channel image with a fully-transparent alpha channel\n * const rgba = await sharp(rgb)\n *   .ensureAlpha(0)\n *   .toBuffer();\n *\n * @param {number} [alpha=1] - alpha transparency level (0=fully-transparent, 1=fully-opaque)\n * @returns {Sharp}\n * @throws {Error} Invalid alpha transparency level\n */\nfunction ensureAlpha (alpha) {\n  if (is.defined(alpha)) {\n    if (is.number(alpha) && is.inRange(alpha, 0, 1)) {\n      this.options.ensureAlpha = alpha;\n    } else {\n      throw is.invalidParameterError('alpha', 'number between 0 and 1', alpha);\n    }\n  } else {\n    this.options.ensureAlpha = 1;\n  }\n  return this;\n}\n\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * // green.jpg is a greyscale image containing the green channel of the input\n * await sharp(input)\n *   .extractChannel('green')\n *   .toFile('green.jpg');\n *\n * @example\n * // red1 is the red value of the first pixel, red2 the second pixel etc.\n * const [red1, red2, ...] = await sharp(input)\n *   .extractChannel(0)\n *   .raw()\n *   .toBuffer();\n *\n * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\nfunction extractChannel (channel) {\n  const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };\n  if (Object.keys(channelMap).includes(channel)) {\n    channel = channelMap[channel];\n  }\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);\n  }\n  return this.toColourspace('b-w');\n}\n\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction joinChannel (images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction bandbool (boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  });\n  // Class attributes\n  Sharp.bool = bool;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}